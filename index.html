<script>
const USER = "jbrimz088";
const REPO = "Jmusic";
const ROOT = "playlist"; // <-- use "playlist" if your folder is playlist/, or "playlists" if it's playlists/

let songs = [];
let order = [];
let index = 0;
let shuffle = false;
let loopOne = false;

const list = document.getElementById("list");
const player = document.getElementById("player");
const shuffleBtn = document.getElementById("shuffleBtn");
const loopBtn = document.getElementById("loopBtn");
const playlistSelect = document.getElementById("playlistSelect");

const API = path => `https://api.github.com/repos/${USER}/${REPO}/contents/${path}`;

fetch(API(ROOT))
  .then(r=>r.json())
  .then(folders=>{
    playlistSelect.innerHTML = "";
    folders.filter(f=>f.type==="dir").forEach(f=>{
      const o=document.createElement("option");
      o.value=f.name;
      o.textContent=f.name;
      playlistSelect.appendChild(o);
    });
    if (playlistSelect.options.length) loadPlaylist(playlistSelect.value);
    else list.textContent = `No playlist folders found in /${ROOT}/`;
  });

playlistSelect.onchange = ()=> loadPlaylist(playlistSelect.value);

function loadPlaylist(name){
  fetch(API(`${ROOT}/${name}`))
    .then(r=>r.json())
    .then(files=>{
      songs = (files || []).filter(f => f.type === "file" && f.name.toLowerCase().endsWith(".mp3"));

      if(!songs.length){
        list.textContent = "No .mp3 files found in this playlist folder.";
        player.removeAttribute("src");
        order = [];
        index = 0;
        return;
      }

      buildOrderKeepCurrent(null); // fresh load
      render();
      play(0);
    });
}

function currentSongId(){
  if(!songs.length || !order.length) return null;
  return songs[order[index]]?.sha || songs[order[index]]?.name || null;
}

function buildOrderKeepCurrent(currentId){
  // default order = alphabetical by name (stable)
  const base = songs
    .map((s,i)=>({s,i}))
    .sort((a,b)=>a.s.name.localeCompare(b.s.name))
    .map(x=>x.i);

  if(!shuffle){
    order = base;
  } else {
    // shuffle but keep current first
    let currIndex = 0;
    if(currentId){
      const found = base.find(i => (songs[i].sha || songs[i].name) === currentId);
      if(found !== undefined) currIndex = base.indexOf(found);
    }
    const curr = base.splice(currIndex, 1)[0];

    // Fisher-Yates shuffle remaining
    for(let i=base.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [base[i],base[j]]=[base[j],base[i]];
    }
    order = [curr, ...base];
  }

  // set index so current song stays playing
  if(currentId){
    const newPos = order.findIndex(i => (songs[i].sha || songs[i].name) === currentId);
    index = newPos >= 0 ? newPos : 0;
  } else {
    index = 0;
  }
}

function render(){
  list.innerHTML="";
  order.forEach((songIdx,pos)=>{
    const b=document.createElement("button");
    b.textContent = songs[songIdx].name;
    b.onclick=()=>{ index=pos; playCurrent(); };
    list.appendChild(b);
  });
}

function play(pos){ index=pos; playCurrent(); }

function playCurrent(){
  if(!order.length) return;
  player.src = songs[order[index]].download_url;
  player.play().catch(()=>{});
}

function next(){
  if(!order.length) return;
  index = (index+1) % order.length;
  playCurrent();
}
function prev(){
  if(!order.length) return;
  index = (index-1+order.length) % order.length;
  playCurrent();
}

shuffleBtn.onclick=()=>{
  const cur = currentSongId();     // remember currently playing song
  shuffle = !shuffle;
  shuffleBtn.textContent=`Shuffle: ${shuffle?"ON":"OFF"}`;
  shuffleBtn.classList.toggle("off",!shuffle);

  buildOrderKeepCurrent(cur);      // rebuild order but KEEP current
  render();
  // DO NOT call play(0) -> this stops it switching songs when you toggle
};

loopBtn.onclick=()=>{
  loopOne=!loopOne;
  loopBtn.textContent=`Loop: ${loopOne?"ON":"OFF"}`;
  loopBtn.classList.toggle("off",!loopOne);
};

player.addEventListener("ended",()=>{
  if(loopOne) playCurrent();
  else next();
});
</script>
